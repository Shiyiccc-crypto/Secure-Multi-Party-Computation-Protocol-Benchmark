import numpy as np
import matplotlib.pyplot as plt
from Crypto.Util import number
import random
import time

class MPCProtocolBenchmark:
    """
    A class to benchmark different secure multi-party computation protocols.
    Includes protocol simulation, timing analysis, and visualization.
    """
    
    def __init__(self):
        # System parameters
        self.p = 17125458317614137930196041979257577826408832324037508573393292981642667139747621778802438775238728592968344613589379932348475613503476932163166973813218698343816463289144185362912602522540494983090531497232965829536524507269848825658311420299335922295709743267508322525966773950394919257576842038771632742044142471053509850123605883815857162666917775193496157372656195558305727009891276006514000409365877218171388319923896309377791762590614311849642961380224851940460421710449368927252974870395873936387909672274883295377481008150475878590270591798350563488168080923804611822387520198054002990623911454389104774092183
        self.q = 63762351364972653564641699529205510489263266834182771617563631363277932854227
        self.g = 8041367327046189302693984665026706374844608289874374425728797669509435881459140662650215832833471328470334064628508692231999401840332046192569287351991689963279656892562484773278584208040987631569628520464069532361274047374444344996651832979378318849943741662110395995778429270819222431610927356005913836932462099770076239554042855287138026806960470277326229482818003962004453764400995790974042663675692120758726145869061236443893509136147942414445551848162391468541444355707785697825741856849161233887307017428371823608125699892904960841221593344499088996021883972185241854777608212592397013510086894908468466292313
        
        # Communication parameters
        self.UPLOAD_SPEED = 20  # Mbps
        self.DOWNLOAD_SPEED = 100  # Mbps
        self.PRIME_SIZE = 2024  # bits
        
        # Convert to bits per second
        self.UPLOAD_SPEED_BITS = self.UPLOAD_SPEED * 10**6
        self.DOWNLOAD_SPEED_BITS = self.DOWNLOAD_SPEED * 10**6
        
        # Visualization settings
        self.PROTOCOL_COLORS = ['#66b3ff', '#ff7f0e', '#99ff99']
        self.BAR_WIDTH = 0.25

    def calculate_transfer_time(self, data_size_bits, speed_bits_per_sec):
        """Calculate data transfer time in seconds"""
        return data_size_bits / speed_bits_per_sec

    def our_protocol_time(self, n):
        """Calculate total time for Our protocol in milliseconds"""
        upload = (3 + 14 + 1) * self.PRIME_SIZE
        download = (n - 1) * self.PRIME_SIZE
        total_sec = (self.calculate_transfer_time(upload, self.UPLOAD_SPEED_BITS) + 
                    self.calculate_transfer_time(download, self.DOWNLOAD_SPEED_BITS))
        return total_sec * 1000

    def vu_protocol_time(self, n):
        """Calculate total time for Vu protocol in milliseconds"""
        upload = (2 + 6 + 14 + 1) * self.PRIME_SIZE
        download = 2 * n * self.PRIME_SIZE
        total_sec = (self.calculate_transfer_time(upload, self.UPLOAD_SPEED_BITS) + 
                    self.calculate_transfer_time(download, self.DOWNLOAD_SPEED_BITS))
        return total_sec * 1000

    def bag_protocol_time(self, n):
        """Calculate total time for Bag protocol in milliseconds"""
        upload = (2 + 6 + 14 + 1) * self.PRIME_SIZE
        download = (n - 1) * self.PRIME_SIZE
        total_sec = (self.calculate_transfer_time(upload, self.UPLOAD_SPEED_BITS) + 
                    self.calculate_transfer_time(download, self.DOWNLOAD_SPEED_BITS))
        return total_sec * 1000

    def simulate_privacy_preservation(self, num_people=500, num_rounds=10, num_experiments=100):
        """
        Simulate privacy preservation across multiple rounds.
        Returns average survivor counts per round.
        """
        all_survivor_counts = []
        
        for _ in range(num_experiments):
            current_sequence = np.random.randint(2, size=num_people)
            survivor_counts = [num_people]
            
            for _ in range(1, num_rounds + 1):
                new_sequence = np.random.randint(2, size=survivor_counts[-1])
                survivors = np.sum(current_sequence[:survivor_counts[-1]] == new_sequence)
                survivor_counts.append(survivors)
                current_sequence = new_sequence[:survivors]
            
            all_survivor_counts.append(survivor_counts)
        
        return np.mean(all_survivor_counts, axis=0)

    def plot_communication_times(self, participant_counts):
        """
        Plot communication time comparison for different protocols.
        """
        timing_data = {
            'Our': [self.our_protocol_time(n) for n in participant_counts],
            'Bag': [self.bag_protocol_time(n) for n in participant_counts],
            'Vu': [self.vu_protocol_time(n) for n in participant_counts]
        }
        
        fig, ax = plt.subplots(figsize=(10, 7))
        x_positions = np.arange(len(participant_counts))
        
        # Plot bars for each protocol
        ax.bar(x_positions - self.BAR_WIDTH, timing_data['Our'], self.BAR_WIDTH, 
               label='Our', color=self.PROTOCOL_COLORS[0])
        ax.bar(x_positions, timing_data['Bag'], self.BAR_WIDTH, 
               label='Bag', color=self.PROTOCOL_COLORS[1])
        ax.bar(x_positions + self.BAR_WIDTH, timing_data['Vu'], self.BAR_WIDTH, 
               label='Vu', color=self.PROTOCOL_COLORS[2])
        
        # Configure plot
        ax.set_xticks(x_positions)
        ax.set_xticklabels(participant_counts, fontsize=14)
        ax.set_yticks(np.arange(0, max(timing_data['Vu']) + 5, 5))
        ax.tick_params(axis='y', labelsize=14)
        ax.set_xlabel('Number of Participants (n)', fontsize=16)
        ax.set_ylabel('Communication Time (ms)', fontsize=16)
        ax.legend(fontsize=14, framealpha=0.9)
        ax.grid(True, linestyle='--', alpha=0.6)
        plt.tight_layout()
        plt.show()

    def plot_privacy_preservation(self, num_people=500, num_rounds=10):
        """
        Plot privacy preservation results comparing key retention vs replacement.
        """
        avg_survivors = self.simulate_privacy_preservation(num_people, num_rounds)
        constant_values = np.full(num_rounds + 1, num_people)
        
        plt.figure(figsize=(10, 6))
        plt.plot(range(num_rounds + 1), constant_values, 
                color='#ff7f0e', marker='o', 
                label='Key Replacement', zorder=5)
        plt.plot(range(num_rounds + 1), avg_survivors, 
                marker='o', label='Key Retention')
        
        plt.xlabel('Number of Protocol Iteration Rounds', fontsize=16)
        plt.ylabel('Number of Privacy-Preserving Participants', fontsize=16)
        plt.xticks(fontsize=14)
        plt.yticks(fontsize=14)
        plt.grid(True)
        plt.legend(fontsize=14)
        plt.tight_layout()
        plt.show()

    def run_benchmarks(self):
        """Run all benchmarks and generate plots"""
        print("Running communication time benchmark...")
        participant_counts = [100, 200, 300, 400, 500]
        self.plot_communication_times(participant_counts)
        
        print("\nRunning privacy preservation simulation...")
        self.plot_privacy_preservation()
        
        print("\nBenchmark completed!")

if __name__ == "__main__":
    benchmark = MPCProtocolBenchmark()
    benchmark.run_benchmarks()
